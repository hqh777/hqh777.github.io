<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>函数式编程上 | hqh777</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="我的世界很简单 简单到我每顿只吃大龙虾什么是函数式编程？函数式编程，缩写FP，是一种编程范式，也是一种编程风格，和面向对象是并列的关系。函数式编程我们可以认为是一种思维模式，加上实现方法。其思维方式就是把现实世界事物和事物之间的联系抽象到程序世界（是对运算过程进行抽象） 常听说的编程范式还有面向过程编程（按照步骤来实现）、面向对象编程（把现实中的事物抽象成类和对象，通过封装、继承和多态来演示不同事">
<meta property="og:type" content="article">
<meta property="og:title" content="函数式编程上">
<meta property="og:url" content="http://example.com/2021/06/04/functional-programming/index.html">
<meta property="og:site_name" content="hqh777">
<meta property="og:description" content="我的世界很简单 简单到我每顿只吃大龙虾什么是函数式编程？函数式编程，缩写FP，是一种编程范式，也是一种编程风格，和面向对象是并列的关系。函数式编程我们可以认为是一种思维模式，加上实现方法。其思维方式就是把现实世界事物和事物之间的联系抽象到程序世界（是对运算过程进行抽象） 常听说的编程范式还有面向过程编程（按照步骤来实现）、面向对象编程（把现实中的事物抽象成类和对象，通过封装、继承和多态来演示不同事">
<meta property="og:locale">
<meta property="article:published_time" content="2021-06-04T13:49:16.000Z">
<meta property="article:modified_time" content="2021-06-10T07:47:56.105Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="hqh777" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">hqh777</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-functional-programming" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/04/functional-programming/" class="article-date">
  <time class="dt-published" datetime="2021-06-04T13:49:16.000Z" itemprop="datePublished">2021-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      函数式编程上
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="我的世界很简单-简单到我每顿只吃大龙虾"><a href="#我的世界很简单-简单到我每顿只吃大龙虾" class="headerlink" title="我的世界很简单 简单到我每顿只吃大龙虾"></a>我的世界很简单 简单到我每顿只吃大龙虾</h3><h2 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h2><p>函数式编程，缩写FP，是一种编程范式，也是一种编程风格，和面向对象是并列的关系。函数式编程我们可以认为是一种思维模式，加上实现方法。其思维方式就是把现实世界事物和事物之间的联系抽象到程序世界（是对运算过程进行抽象）</p>
<p>常听说的编程范式还有面向过程编程（按照步骤来实现）、面向对象编程（把现实中的事物抽象成类和对象，通过封装、继承和多态来演示不同事物之间的联系）。</p>
<h3 id="函数式编程和面向对象编程的不同"><a href="#函数式编程和面向对象编程的不同" class="headerlink" title="函数式编程和面向对象编程的不同"></a>函数式编程和面向对象编程的不同</h3><ul>
<li>从思维方式上来说<br>面向对象编程是对事物的抽象，而函数式编程是对运算过程的抽象</li>
</ul>
<h3 id="对于函数式编程思维方式的理解："><a href="#对于函数式编程思维方式的理解：" class="headerlink" title="对于函数式编程思维方式的理解："></a>对于函数式编程思维方式的理解：</h3><ul>
<li>程序的本质：根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多输入和输出的函数。</li>
<li>函数式编程中的函数指的不是程序中的函数Function，而是数学中的函数即映射关系，例如：y=sin(x)，是这种x和y的关系</li>
<li>相同的输入时总要得到相同的输出（纯函数）</li>
<li>函数式编程用描述数据（函数）之间的映射</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非函数式</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> sum = num1 + num2</span><br><span class="line"><span class="built_in">console</span>.log(sum)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sum = add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum)</span><br></pre></td></tr></table></figure>
<h2 id="函数式编程的前置知识"><a href="#函数式编程的前置知识" class="headerlink" title="函数式编程的前置知识"></a>函数式编程的前置知识</h2><p>在JS中函数就是一个普通的对象，我们可以把函数存储到变量/数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过<code>new Function(&#39;alert(1)&#39;)</code>来构造一个新的函数。</p>
<ul>
<li>函数可以存储在变量中<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把函数赋值给变量</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个示例</span></span><br><span class="line"><span class="keyword">const</span> BlogController = &#123;</span><br><span class="line">    index (posts) &#123; <span class="keyword">return</span> Views.index(posts) &#125;,</span><br><span class="line">    show (post) &#123; <span class="keyword">return</span> Views.show(post) &#125;,</span><br><span class="line">    create (attrs) &#123; <span class="keyword">return</span> Db.create(attrs) &#125;,</span><br><span class="line">    update (post, attrs) &#123; <span class="keyword">return</span> Db.update(post, attrs) &#125;,</span><br><span class="line">    destroy (post) &#123; <span class="keyword">return</span> Db.destroy(post) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化 赋值的是Views的index方法，不是方法的调用</span></span><br><span class="line"><span class="keyword">const</span> BlogController = &#123;</span><br><span class="line">    <span class="attr">index</span>: Views.index,</span><br><span class="line">    <span class="attr">show</span>: Views.show,</span><br><span class="line">    <span class="attr">create</span>: Db.create,</span><br><span class="line">    <span class="attr">update</span>: Db.update,</span><br><span class="line">    <span class="attr">destroy</span>: Db.destroy</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
下面两个特性在高阶函数中会有详细说明</li>
<li>函数可以作为参数</li>
<li>函数可以作为返回值</li>
</ul>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数（Higher-order function）</p>
<ul>
<li>函数可以作为参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach</span></span><br><span class="line"><span class="comment">// 定义一个遍历数组的并对每一项做处理的函数，第一个函数是一个数组，第二个参数是一个函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span> (<span class="params">array, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        fn(array[i]) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">forEach(arr, <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    item = item * <span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.log(item) <span class="comment">// 2 4 6</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="comment">// 遍历数组，并把满足条件的元素存储成数组，再进行返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">array, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> results = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123; </span><br><span class="line">        <span class="comment">//如果满足条件  </span></span><br><span class="line">        <span class="keyword">if</span> (fn(array[i])) &#123; </span><br><span class="line">            results.push(array[i]) </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> result = filter(arr, <span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// [4, 8]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数作为返回值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个函数返回另一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;Hello function&#x27;</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(msg) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="comment">// 第一种调用方式</span></span><br><span class="line"><span class="keyword">const</span> fn = makeFn() </span><br><span class="line">fn() <span class="comment">//Hello function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种调用方式</span></span><br><span class="line">makeFn()()<span class="comment">///Hello function</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// once</span></span><br><span class="line"><span class="comment">// 让函数只执行一次</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> done = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 判断值有没有被执行，如果是false表示没有执行，如果是true表示已经执行过了，不必再执行</span></span><br><span class="line">        <span class="keyword">if</span>(!done) &#123;</span><br><span class="line">            done = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 调用fn，当前this直接传递过来，第二个参数是把fn的参数传递给return的函数</span></span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> pay = once(<span class="function"><span class="keyword">function</span> (<span class="params">money</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`支付：<span class="subst">$&#123;money&#125;</span> RMB`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">pay(<span class="number">5</span>) <span class="comment">//支付：5 RMB</span></span><br><span class="line">pay(<span class="number">5</span>)</span><br><span class="line">pay(<span class="number">5</span>)</span><br><span class="line">pay(<span class="number">5</span>)</span><br><span class="line">pay(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h4 id="使用高阶函数的意义"><a href="#使用高阶函数的意义" class="headerlink" title="使用高阶函数的意义"></a>使用高阶函数的意义</h4><ul>
<li>抽象可以帮我们屏蔽细节，我们只需要知道我们的目标和解决这类问题的函数，我们不需要关心实现的细节</li>
<li>高阶函数是用来抽象通用的问题</li>
</ul>
<h4 id="常用的高阶函数"><a href="#常用的高阶函数" class="headerlink" title="常用的高阶函数"></a>常用的高阶函数</h4><p>有一个通用的特点，就是需要一个函数作为参数。</p>
<ul>
<li>forEach</li>
<li>map<br>对数组中的每个元素进行遍历，并处理，处理的结果放在一个新数组中返回<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function">(<span class="params">array, fn</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">let</span> results = [] </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> array) &#123; </span><br><span class="line">        results.push(fn(value)) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr = map(arr, <span class="function"><span class="params">v</span> =&gt;</span> v * v)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure></li>
<li>filter</li>
<li>every<br>数组中的每一个元素是否都匹配我们指定的一个条件，如果都满足返回true，如果不满足返回false<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> every = <span class="function">(<span class="params">array, fn</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">true</span> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">        result = fn(value) </span><br><span class="line">        <span class="comment">// 如果有一个元素不满足就直接跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123; </span><br><span class="line">            <span class="keyword">break</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>]</span><br><span class="line"><span class="keyword">let</span> r = every(arr, <span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">r = every(arr, <span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">12</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r) <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li>some<br>判断数组中是否有一个元素满足我们指定的条件，满足是true，都不满足为false<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> some = <span class="function">(<span class="params">array, fn</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">false</span> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">        result = fn(value) </span><br><span class="line">        <span class="comment">// 如果有一个元素不满足就直接跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (result) &#123; </span><br><span class="line">            <span class="keyword">break</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> r = some(arr, <span class="function"><span class="params">v</span> =&gt;</span> v % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r) <span class="comment">// true</span></span><br><span class="line">r = some(arr1, <span class="function"><span class="params">v</span> =&gt;</span> v % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>find/findIndex</li>
<li>reduce</li>
<li>sort</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h4><p>闭包：函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包</p>
<ul>
<li>可以在另一个作用域中调用一个函数的内部函数并访问到该函数作用域中的成员</li>
</ul>
<p>在上面函数作为返回值的过程中，其实我们就用到了闭包，下面进行语法演示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;Hello function&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常情况下，执行完makeFn，里面的变量msg会释放掉</span></span><br><span class="line"><span class="comment">// 但是下面的情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;Hello function&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(msg)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在上面函数中，返回了一个函数，而且在函数中还访问了原来函数内部的成员，就可以称为闭包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = makeFn()</span><br><span class="line">fn()</span><br><span class="line"><span class="comment">// fn为外部函数，当外部函数对内部成员有引用的时候，那么内部的成员msg就不能被释放。当我们调用fn的时候，我们就会访问到msg。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意的点：</span></span><br><span class="line"><span class="comment">//1、我们可以在另一个作用域调用makeFn的内部函数</span></span><br><span class="line"><span class="comment">//2、当我们调用内部函数的时候我们可以访问到内部成员</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="闭包的核心作用"><a href="#闭包的核心作用" class="headerlink" title="闭包的核心作用"></a>闭包的核心作用</h4><p>把函数内部成员的作用范围延长</p>
<h4 id="闭包的本质"><a href="#闭包的本质" class="headerlink" title="闭包的本质"></a>闭包的本质</h4><p>函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除。但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。</p>
<p>/<em>解读：函数执行的时候在执行栈上，执行完毕之后从执行栈上移除，内部成员的内存被释放。但是在函数执行完毕移除之后，释放内存的时候，如果外部有引用，则内部成员的内存不能被释放。</em>/</p>
<h4 id="闭包的案例"><a href="#闭包的案例" class="headerlink" title="闭包的案例"></a>闭包的案例</h4><h5 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h5><p>计算一个数平方和立方的运算</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 后面的二次方三次方很多次重复，下面要写一个二次方三次方的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePower</span> (<span class="params">power</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(number, power)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求平方</span></span><br><span class="line"><span class="keyword">let</span> power2 = makePower(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> power3 = makePower(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(power2(<span class="number">4</span>)) <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(power2(<span class="number">5</span>)) <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(power3(<span class="number">4</span>)) <span class="comment">// 64</span></span><br></pre></td></tr></table></figure>
<h5 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h5><p>计算不同级别的员工工资</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设计算员工工资的函数第一个函数传基本工资，第二个参数传绩效工资</span></span><br><span class="line"><span class="comment">// getSalary(12000, 2000)</span></span><br><span class="line"><span class="comment">// getSalary(15000, 3000)</span></span><br><span class="line"><span class="comment">// getSalary(15000, 4000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同级别的员工基本工资是一样的，所以我们将基本工资提取出来，之后只需要加上绩效工资</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeSalary</span> (<span class="params">base</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">performance</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> base + performance </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> salaryLevel1 = makeSalary(<span class="number">12000</span>)</span><br><span class="line"><span class="keyword">let</span> salaryLevel2 = makeSalary(<span class="number">15000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(salaryLevel1(<span class="number">2000</span>)) <span class="comment">//14000</span></span><br><span class="line"><span class="built_in">console</span>.log(salaryLevel2(<span class="number">3000</span>)) <span class="comment">//18000</span></span><br><span class="line"><span class="built_in">console</span>.log(salaryLevel2(<span class="number">4000</span>)) <span class="comment">//19000</span></span><br></pre></td></tr></table></figure>

<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><h3 id="纯函数的概念"><a href="#纯函数的概念" class="headerlink" title="纯函数的概念"></a>纯函数的概念</h3><p><strong>相同的输入永远会得到相同的输出</strong>，而且没有任何可观察的副作用。</p>
<p>纯函数就类似数学中的函数(用来描述输入和输出之间的关系)，y = f(x)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] </span><br><span class="line"><span class="comment">// 纯函数 </span></span><br><span class="line"><span class="comment">// 对于相同的函数，输出是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice方法，截取的时候返回截取的函数，不影响原数组</span></span><br><span class="line">numbers.slice(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// =&gt; [1, 2, 3] </span></span><br><span class="line">numbers.slice(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// =&gt; [1, 2, 3] </span></span><br><span class="line">numbers.slice(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// =&gt; [1, 2, 3] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不纯的函数 </span></span><br><span class="line"><span class="comment">// 对于相同的输入，输出是不一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// splice方法，返回原数组，改变原数组</span></span><br><span class="line">numbers.splice(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// =&gt; [1, 2, 3] </span></span><br><span class="line">numbers.splice(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// =&gt; [4, 5] </span></span><br><span class="line">numbers.splice(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// =&gt; []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面函数也是纯函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSum</span> (<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(getSum(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数式编程不会保留计算中间的结果，所以变量是不可变的(无状态的)</li>
<li>我们也可以把一个函数的执行结果交给另一个函数处理</li>
</ul>
<h3 id="Lodash——纯函数的代表"><a href="#Lodash——纯函数的代表" class="headerlink" title="Lodash——纯函数的代表"></a>Lodash——纯函数的代表</h3><ul>
<li>lodash 是一个纯函数的功能库，提供了模块化、高性能以及一些附加功能。提供了对数组、数字、对象、字符串、函数等操作的一些方法</li>
</ul>
<h4 id="体验Lodash"><a href="#体验Lodash" class="headerlink" title="体验Lodash"></a>体验Lodash</h4><ul>
<li>安装</li>
</ul>
<p>新建文件夹 -&gt; npm init -y -&gt; npm i lodash</p>
<ul>
<li>体验</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> array = [<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;lucy&#x27;</span>, <span class="string">&#x27;kate&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// head的别名是first  _.head(array)也可以</span></span><br><span class="line"><span class="built_in">console</span>.log(_.first(array)) <span class="comment">//jack</span></span><br><span class="line"><span class="built_in">console</span>.log(_.last(array)) <span class="comment">//kate</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.toUpper(_.first(array))) <span class="comment">//JACK</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.reverse(array))  <span class="comment">//[ &#x27;kate&#x27;, &#x27;lucy&#x27;, &#x27;tom&#x27;, &#x27;jack&#x27; ]</span></span><br><span class="line"><span class="comment">// 数组的翻转不是纯函数，因为会改变原数组。这里的reserve是使用了数组的reverse，所以也不是纯函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> r = _.each(array, <span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item, index)</span><br><span class="line">  <span class="comment">// kate 0</span></span><br><span class="line">  <span class="comment">// lucy 1</span></span><br><span class="line">  <span class="comment">// tom 2</span></span><br><span class="line">  <span class="comment">// jack 3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(r) <span class="comment">// [ &#x27;kate&#x27;, &#x27;lucy&#x27;, &#x27;tom&#x27;, &#x27;jack&#x27; ]</span></span><br></pre></td></tr></table></figure>
<h3 id="纯函数的好处"><a href="#纯函数的好处" class="headerlink" title="纯函数的好处"></a>纯函数的好处</h3><h4 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h4><p>因为对于相同的输入始终有相同的结果，那么可以把纯函数的结果缓存起来，可以提高性能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * r * r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getAreaWithMemory = _.memoize(getArea)</span><br><span class="line"><span class="built_in">console</span>.log(getAreaWithMemory(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getAreaWithMemory(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getAreaWithMemory(<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 50.26548245743669</span></span><br><span class="line"><span class="comment">// 50.26548245743669</span></span><br><span class="line"><span class="comment">// 50.26548245743669</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看到输出的4只执行了一次，因为其结果被缓存下来了</span></span><br></pre></td></tr></table></figure>
<p>那我们可以模拟一个记忆函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cache = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arguments是一个伪数组，所以要进行字符串的转化</span></span><br><span class="line">    <span class="keyword">let</span> key = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// 如果缓存中有值就把值赋值，没有值就调用f函数并且把参数传递给它</span></span><br><span class="line">    cache[key] = cache[key] || f.apply(f,<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> cache[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getAreaWithMemory1 = memoize(getArea)</span><br><span class="line"><span class="built_in">console</span>.log(getAreaWithMemory1(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getAreaWithMemory1(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getAreaWithMemory1(<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 50.26548245743669</span></span><br><span class="line"><span class="comment">// 50.26548245743669</span></span><br><span class="line"><span class="comment">// 50.26548245743669</span></span><br></pre></td></tr></table></figure>
<h4 id="可测试"><a href="#可测试" class="headerlink" title="可测试"></a>可测试</h4><p>纯函数让测试更加的方便</p>
<h4 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h4><ul>
<li>多线程环境下并行操作共享的内存数据很可能会出现意外情况。纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数</li>
<li>虽然JS是单线程，但是ES6以后有一个Web Worker，可以开启一个新线程</li>
</ul>
<h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>副作用就是让一个函数变得不纯，纯函数的根据市相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用，如下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不纯的函数，因为它依赖于外部的变量</span></span><br><span class="line"><span class="keyword">let</span> mini = <span class="number">18</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAge</span> (<span class="params">age</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> age &gt;= mini </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>副作用来源：</p>
<ul>
<li>配置文件</li>
<li>数据库</li>
<li>获取用户的输入</li>
<li>……</li>
</ul>
<p>所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，我们不能禁止用户输入用户名和密码，只能尽可能控制它们在可控范围内发生。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/04/functional-programming/" data-id="ckpqlmkni00000nqc7ewvfxrp" data-title="函数式编程上" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/06/10/web-engineering/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          前端工程化
        
      </div>
    </a>
  
  
    <a href="/2021/06/01/web-standard/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">前端规范</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/10/web-engineering/">前端工程化</a>
          </li>
        
          <li>
            <a href="/2021/06/04/functional-programming/">函数式编程上</a>
          </li>
        
          <li>
            <a href="/2021/06/01/web-standard/">前端规范</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>